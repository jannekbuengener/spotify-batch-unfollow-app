{"version":3,"file":"static/js/701.9c75f503.chunk.js","mappings":"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","sources":["../node_modules/@tasoskakour/react-use-oauth2/dist/esm/index.js","../../packages/react-router-dom/index.tsx","../../packages/react-router/lib/context.ts","../../packages/react-router/lib/router.ts","../../packages/react-router/lib/hooks.tsx","../../packages/react-router/lib/components.tsx","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["import{jsx as e}from\"react/jsx-runtime\";import{useEffect as r,useSyncExternalStore as n,useState as t,useRef as o,useCallback as i,useMemo as a}from\"react\";var c=function(){return c=Object.assign||function(e){for(var r,n=1,t=arguments.length;n<t;n++)for(var o in r=arguments[n])Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o]);return e},c.apply(this,arguments)};function u(e,r,n,t){return new(n||(n=Promise))((function(o,i){function a(e){try{u(t.next(e))}catch(e){i(e)}}function c(e){try{u(t.throw(e))}catch(e){i(e)}}function u(e){var r;e.done?o(e.value):(r=e.value,r instanceof n?r:new n((function(e){e(r)}))).then(a,c)}u((t=t.apply(e,r||[])).next())}))}function s(e,r){var n,t,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:c(0),throw:c(1),return:c(2)},\"function\"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function c(c){return function(u){return function(c){if(n)throw new TypeError(\"Generator is already executing.\");for(;i&&(i=0,c[0]&&(a=0)),a;)try{if(n=1,t&&(o=2&c[0]?t.return:c[0]?t.throw||((o=t.return)&&o.call(t),0):t.next)&&!(o=o.call(t,c[1])).done)return o;switch(t=0,o&&(c=[2&c[0],o.value]),c[0]){case 0:case 1:o=c;break;case 4:return a.label++,{value:c[1],done:!1};case 5:a.label++,t=c[1],c=[0];continue;case 7:c=a.ops.pop(),a.trys.pop();continue;default:if(!(o=a.trys,(o=o.length>0&&o[o.length-1])||6!==c[0]&&2!==c[0])){a=0;continue}if(3===c[0]&&(!o||c[1]>o[0]&&c[1]<o[3])){a.label=c[1];break}if(6===c[0]&&a.label<o[1]){a.label=o[1],o=c;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(c);break}o[2]&&a.ops.pop(),a.trys.pop();continue}c=r.call(e,a)}catch(e){c=[6,e],t=0}finally{n=o=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([c,u])}}}var l=\"react-use-oauth2-state-key\",d=\"react-use-oauth2-response\",f=function(e){return new URLSearchParams(e).toString()},p=function(e){var r=new URLSearchParams(e);return Object.fromEntries(r.entries())},v=function(e,r){return e.postMessage(r)},h=function(e,r,n){clearInterval(e.current),r.current&&\"function\"==typeof r.current.close&&function(e){var r;null===(r=e.current)||void 0===r||r.close()}(r),sessionStorage.removeItem(l),window.removeEventListener(\"message\",n)},w=function(e,r,n,t,o){var i=e.split(\"?\")[0],a=p(e.split(\"?\")[1]);return\"\".concat(i,\"?\").concat(f(c(c({},a),{client_id:r,grant_type:\"authorization_code\",code:n,redirect_uri:t,state:o})))},g=function(n){var t=n.Component,o=void 0===t?e(\"div\",c({style:{margin:\"12px\"},\"data-testid\":\"popup-loading\"},{children:\"Loading...\"})):t;return r((function(){var e=c(c({},p(window.location.search.split(\"?\")[1])),p(window.location.hash.split(\"#\")[1])),r=null==e?void 0:e.state,n=null==e?void 0:e.error,t=null===window||void 0===window?void 0:window.opener;if(!function(e){return null!=e}(t))throw new Error(\"No window opener\");var o,i=r&&(o=r,sessionStorage.getItem(l)===o);if(!n&&i)v(t,{type:d,payload:e});else{var a=n?decodeURI(n):i?\"OAuth error: An error has occured.\":\"OAuth error: State mismatch.\";v(t,{type:d,error:a})}}),[]),o};const m=new Map;function y(e,c){if(void 0===n)throw new TypeError('You are using React 17 or below. Install with \"npm install use-local-storage-state@17\".');const[u]=t(null==c?void 0:c.defaultValue);if(\"undefined\"==typeof window)return[u,()=>{},{isPersistent:!0,removeItem:()=>{}}];const s=null==c?void 0:c.serializer;return function(e,t,c=!0,u=E,s=JSON.stringify){if(!m.has(e)&&void 0!==t&&null===localStorage.getItem(e))try{localStorage.setItem(e,s(t))}catch(e){}const l=o({item:null,parsed:t}),d=n(i((r=>{const n=n=>{e===n&&r()};return b.add(n),()=>{b.delete(n)}}),[e]),(()=>{const r=localStorage.getItem(e);if(m.has(e))l.current={item:r,parsed:m.get(e)};else if(r!==l.current.item){let e;try{e=null===r?t:u(r)}catch(r){e=t}l.current={item:r,parsed:e}}return l.current.parsed}),(()=>t)),f=i((r=>{const n=r instanceof Function?r(l.current.parsed):r;try{localStorage.setItem(e,s(n)),m.delete(e)}catch(r){m.set(e,n)}S(e)}),[e,s]);return r((()=>{if(!c)return;const r=r=>{r.storageArea===localStorage&&r.key===e&&S(e)};return window.addEventListener(\"storage\",r),()=>window.removeEventListener(\"storage\",r)}),[e,c]),a((()=>[d,f,{isPersistent:d===t||!m.has(e),removeItem(){m.delete(e),localStorage.removeItem(e),S(e)}}]),[e,f,d,t])}(e,u,null==c?void 0:c.storageSync,null==s?void 0:s.parse,null==s?void 0:s.stringify)}const b=new Set;function S(e){for(const r of[...b])r(e)}function E(e){return\"undefined\"===e?void 0:JSON.parse(e)}var I=function(e){var r=e.authorizeUrl,n=e.clientId,a=e.redirectUri,p=e.scope,v=void 0===p?\"\":p,g=e.responseType,m=e.extraQueryParameters,b=void 0===m?{}:m,S=e.onSuccess,E=e.onError;!function(e){var r=e.authorizeUrl,n=e.clientId,t=e.redirectUri,o=e.responseType,i=e.extraQueryParameters,a=void 0===i?{}:i,c=e.onSuccess,u=e.onError;if(!(r&&n&&t&&o))throw new Error(\"Missing required props for useOAuth2. Required props are: {authorizeUrl, clientId, redirectUri, responseType}\");if(\"code\"===o&&!e.exchangeCodeForTokenServerURL)throw new Error('exchangeCodeForTokenServerURL is required for responseType of \"code\" for useOAuth2.');if(\"code\"===o&&e.exchangeCodeForTokenMethod&&![\"POST\",\"GET\"].includes(e.exchangeCodeForTokenMethod))throw new Error('Invalid exchangeCodeForTokenServerURL value. It can be one of \"POST\" or \"GET\".');if(\"object\"!=typeof a)throw new TypeError(\"extraQueryParameters must be an object for useOAuth2.\");if(c&&\"function\"!=typeof c)throw new TypeError(\"onSuccess callback must be a function for useOAuth2.\");if(u&&\"function\"!=typeof u)throw new TypeError(\"onError callback must be a function for useOAuth2.\")}(e);var I=o(b),T=o(),x=o(),O=t({loading:!1,error:null}),P=O[0],k=P.loading,U=P.error,A=O[1],L=y(\"\".concat(g,\"-\").concat(r,\"-\").concat(n,\"-\").concat(v),{defaultValue:null}),C=L[0],R=L[1],F=L[2],j=F.removeItem,M=F.isPersistent,_=\"code\"===g&&e.exchangeCodeForTokenServerURL,z=\"code\"===g&&e.exchangeCodeForTokenMethod,q=i((function(){A({loading:!0,error:null});var e,t,o,i,p,m=(e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",t=new Uint8Array(40),window.crypto.getRandomValues(t),t=t.map((function(r){return e.codePointAt(r%e.length)})),String.fromCharCode.apply(null,t));function y(e){var r,t,o;return u(this,void 0,void 0,(function(){var i,c,u;return s(this,(function(s){switch(s.label){case 0:if((null===(r=null==e?void 0:e.data)||void 0===r?void 0:r.type)!==d)return[2];s.label=1;case 1:return s.trys.push([1,10,11,12]),\"error\"in e.data?(i=(null===(t=e.data)||void 0===t?void 0:t.error)||\"Unknown Error occured.\",A({loading:!1,error:i}),E?[4,E(i)]:[3,3]):[3,4];case 2:s.sent(),s.label=3;case 3:return[3,9];case 4:return c=null===(o=null==e?void 0:e.data)||void 0===o?void 0:o.payload,\"code\"===g&&_?[4,fetch(w(_,n,null==c?void 0:c.code,a,m),{method:z||\"POST\"})]:[3,7];case 5:return[4,s.sent().json()];case 6:c=s.sent(),s.label=7;case 7:return A({loading:!1,error:null}),R(c),S?[4,S(c)]:[3,9];case 8:s.sent(),s.label=9;case 9:return[3,12];case 10:return u=s.sent(),console.error(u),A({loading:!1,error:u.toString()}),[3,12];case 11:return h(x,T,y),[7];case 12:return[2]}}))}))}return function(e){sessionStorage.setItem(l,e)}(m),T.current=(o=function(e,r,n,t,o,i,a){void 0===a&&(a={});var u=f(c({response_type:i,client_id:r,redirect_uri:n,scope:t,state:o},a));return\"\".concat(e,\"?\").concat(u)}(r,n,a,v,m,g,I.current),i=window.outerHeight/2+window.screenY-350,p=window.outerWidth/2+window.screenX-300,window.open(o,\"OAuth2 Popup\",\"height=\".concat(700,\",width=\").concat(600,\",top=\").concat(i,\",left=\").concat(p))),window.addEventListener(\"message\",y),x.current=setInterval((function(){var e,r,n;(!(null===(e=T.current)||void 0===e?void 0:e.window)||(null===(n=null===(r=T.current)||void 0===r?void 0:r.window)||void 0===n?void 0:n.closed))&&(A((function(e){return c(c({},e),{loading:!1})})),console.warn(\"Warning: Popup was closed before completing authentication.\"),h(x,T,y))}),250),function(){window.removeEventListener(\"message\",y),x.current&&clearInterval(x.current)}}),[r,n,a,v,g,_,z,S,E,A,R]);return{data:C,loading:k,error:U,getAuth:q,logout:i((function(){j(),A({loading:!1,error:null})}),[j]),isPersistent:M}};export{g as OAuthPopup,I as useOAuth2};\n","/**\n * NOTE: If you refactor this to split up the modules into separate files,\n * you'll need to update the rollup config for react-router-dom-v5-compat.\n */\nimport * as React from \"react\";\nimport type { BrowserHistory, HashHistory, History } from \"history\";\nimport { createBrowserHistory, createHashHistory } from \"history\";\nimport {\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createRoutesFromChildren,\n  generatePath,\n  matchRoutes,\n  matchPath,\n  createPath,\n  parsePath,\n  resolvePath,\n  renderMatches,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n  useOutletContext,\n} from \"react-router\";\nimport type { To } from \"react-router\";\n\nfunction warning(cond: boolean, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// RE-EXPORTS\n////////////////////////////////////////////////////////////////////////////////\n\n// Note: Keep in sync with react-router exports!\nexport {\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Route,\n  Router,\n  Routes,\n  createRoutesFromChildren,\n  generatePath,\n  matchRoutes,\n  matchPath,\n  createPath,\n  parsePath,\n  renderMatches,\n  resolvePath,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigate,\n  useNavigationType,\n  useOutlet,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n  useOutletContext,\n};\n\nexport { NavigationType } from \"react-router\";\nexport type {\n  Hash,\n  Location,\n  Path,\n  To,\n  MemoryRouterProps,\n  NavigateFunction,\n  NavigateOptions,\n  NavigateProps,\n  Navigator,\n  OutletProps,\n  Params,\n  PathMatch,\n  RouteMatch,\n  RouteObject,\n  RouteProps,\n  PathRouteProps,\n  LayoutRouteProps,\n  IndexRouteProps,\n  RouterProps,\n  Pathname,\n  Search,\n  RoutesProps,\n} from \"react-router\";\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  UNSAFE_NavigationContext,\n  UNSAFE_LocationContext,\n  UNSAFE_RouteContext,\n} from \"react-router\";\n\n////////////////////////////////////////////////////////////////////////////////\n// COMPONENTS\n////////////////////////////////////////////////////////////////////////////////\n\nexport interface BrowserRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport function BrowserRouter({\n  basename,\n  children,\n  window,\n}: BrowserRouterProps) {\n  let historyRef = React.useRef<BrowserHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HashRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nexport function HashRouter({ basename, children, window }: HashRouterProps) {\n  let historyRef = React.useRef<HashHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HistoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  history: History;\n}\n\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter({ basename, children, history }: HistoryRouterProps) {\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nif (__DEV__) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n\nexport { HistoryRouter as unstable_HistoryRouter };\n\nfunction isModifiedEvent(event: React.MouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nexport interface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  to: To;\n}\n\n/**\n * The public API for rendering a history-aware <a>.\n */\nexport const Link = React.forwardRef<HTMLAnchorElement, LinkProps>(\n  function LinkWithRef(\n    { onClick, reloadDocument, replace = false, state, target, to, ...rest },\n    ref\n  ) {\n    let href = useHref(to);\n    let internalOnClick = useLinkClickHandler(to, { replace, state, target });\n    function handleClick(\n      event: React.MouseEvent<HTMLAnchorElement, MouseEvent>\n    ) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented && !reloadDocument) {\n        internalOnClick(event);\n      }\n    }\n\n    return (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      <a\n        {...rest}\n        href={href}\n        onClick={handleClick}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  Link.displayName = \"Link\";\n}\n\nexport interface NavLinkProps\n  extends Omit<LinkProps, \"className\" | \"style\" | \"children\"> {\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean }) => React.ReactNode);\n  caseSensitive?: boolean;\n  className?: string | ((props: { isActive: boolean }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: { isActive: boolean }) => React.CSSProperties);\n}\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nexport const NavLink = React.forwardRef<HTMLAnchorElement, NavLinkProps>(\n  function NavLinkWithRef(\n    {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      children,\n      ...rest\n    },\n    ref\n  ) {\n    let location = useLocation();\n    let path = useResolvedPath(to);\n\n    let locationPathname = location.pathname;\n    let toPathname = path.pathname;\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      toPathname = toPathname.toLowerCase();\n    }\n\n    let isActive =\n      locationPathname === toPathname ||\n      (!end &&\n        locationPathname.startsWith(toPathname) &&\n        locationPathname.charAt(toPathname.length) === \"/\");\n\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n\n    let className: string | undefined;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp({ isActive });\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [classNameProp, isActive ? \"active\" : null]\n        .filter(Boolean)\n        .join(\" \");\n    }\n\n    let style =\n      typeof styleProp === \"function\" ? styleProp({ isActive }) : styleProp;\n\n    return (\n      <Link\n        {...rest}\n        aria-current={ariaCurrent}\n        className={className}\n        ref={ref}\n        style={style}\n        to={to}\n      >\n        {typeof children === \"function\" ? children({ isActive }) : children}\n      </Link>\n    );\n  }\n);\n\nif (__DEV__) {\n  NavLink.displayName = \"NavLink\";\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// HOOKS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nexport function useLinkClickHandler<E extends Element = HTMLAnchorElement>(\n  to: To,\n  {\n    target,\n    replace: replaceProp,\n    state,\n  }: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n  } = {}\n): (event: React.MouseEvent<E, MouseEvent>) => void {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to);\n\n  return React.useCallback(\n    (event: React.MouseEvent<E, MouseEvent>) => {\n      if (\n        event.button === 0 && // Ignore everything but left clicks\n        (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n        !isModifiedEvent(event) // Ignore clicks with modifier keys\n      ) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here.\n        let replace =\n          !!replaceProp || createPath(location) === createPath(path);\n\n        navigate(to, { replace, state });\n      }\n    },\n    [location, navigate, path, replaceProp, state, target, to]\n  );\n}\n\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nexport function useSearchParams(defaultInit?: URLSearchParamsInit) {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not ` +\n      `support the URLSearchParams API. If you need to support Internet ` +\n      `Explorer 11, we recommend you load a polyfill such as ` +\n      `https://github.com/ungap/url-search-params\\n\\n` +\n      `If you're unsure how to load polyfills, we recommend you check out ` +\n      `https://polyfill.io/v3/ which provides some recommendations about how ` +\n      `to load polyfills only for users that need them, instead of for every ` +\n      `user.`\n  );\n\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n\n  let location = useLocation();\n  let searchParams = React.useMemo(() => {\n    let searchParams = createSearchParams(location.search);\n\n    for (let key of defaultSearchParamsRef.current.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParamsRef.current.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n\n    return searchParams;\n  }, [location.search]);\n\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback(\n    (\n      nextInit: URLSearchParamsInit,\n      navigateOptions?: { replace?: boolean; state?: any }\n    ) => {\n      navigate(\"?\" + createSearchParams(nextInit), navigateOptions);\n    },\n    [navigate]\n  );\n\n  return [searchParams, setSearchParams] as const;\n}\n\nexport type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(\n  init: URLSearchParamsInit = \"\"\n): URLSearchParams {\n  return new URLSearchParams(\n    typeof init === \"string\" ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams\n      ? init\n      : Object.keys(init).reduce((memo, key) => {\n          let value = init[key];\n          return memo.concat(\n            Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n          );\n        }, [] as ParamKeyValuePair[])\n  );\n}\n","import * as React from \"react\";\nimport type { History, Location } from \"history\";\nimport { Action as NavigationType } from \"history\";\n\nimport type { RouteMatch } from \"./router\";\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\ninterface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n","import type { Location, Path, To } from \"history\";\nimport { parsePath } from \"history\";\n\nexport function invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nexport function warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nexport function warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  element?: React.ReactNode;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, (_) =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n","import * as React from \"react\";\nimport type { Location, Path, To } from \"history\";\nimport { Action as NavigationType, parsePath } from \"history\";\n\nimport { LocationContext, NavigationContext, RouteContext } from \"./context\";\nimport type {\n  ParamParseKey,\n  Params,\n  PathMatch,\n  PathPattern,\n  RouteMatch,\n  RouteObject,\n} from \"./router\";\nimport {\n  getToPathname,\n  invariant,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  resolveTo,\n  warning,\n  warningOnce,\n} from \"./router\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = []\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : outlet\n        }\n        value={{\n          outlet,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n","import * as React from \"react\";\nimport type { InitialEntry, Location, MemoryHistory, To } from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath,\n} from \"history\";\n\nimport { LocationContext, NavigationContext, Navigator } from \"./context\";\nimport {\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n} from \"./hooks\";\nimport type { RouteMatch, RouteObject } from \"./router\";\nimport { invariant, normalizePathname, stripBasename, warning } from \"./router\";\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  index?: false;\n  path: string;\n}\n\nexport interface LayoutRouteProps {\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n}\n\nexport interface IndexRouteProps {\n  element?: React.ReactNode | null;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"names":["c","Object","assign","e","r","n","t","arguments","length","o","prototype","hasOwnProperty","call","apply","this","l","d","f","URLSearchParams","toString","p","fromEntries","entries","v","postMessage","h","clearInterval","current","close","sessionStorage","removeItem","window","removeEventListener","w","i","split","a","concat","client_id","grant_type","code","redirect_uri","state","g","Component","style","margin","children","location","search","hash","error","opener","Error","getItem","type","payload","decodeURI","m","Map","y","TypeError","defaultValue","u","isPersistent","s","serializer","E","JSON","stringify","has","localStorage","setItem","item","parsed","b","add","delete","get","Function","set","S","storageArea","key","addEventListener","storageSync","parse","Set","I","authorizeUrl","clientId","redirectUri","scope","responseType","extraQueryParameters","onSuccess","onError","exchangeCodeForTokenServerURL","exchangeCodeForTokenMethod","includes","T","x","O","loading","P","k","U","A","L","C","R","F","j","M","_","z","q","Uint8Array","crypto","getRandomValues","map","codePointAt","String","fromCharCode","Promise","next","throw","done","value","then","label","sent","trys","ops","return","Symbol","iterator","pop","push","data","fetch","method","json","console","response_type","outerHeight","screenY","outerWidth","screenX","open","setInterval","closed","warn","getAuth","logout","BrowserRouter","basename","historyRef","React","createBrowserHistory","history","action","setState","listen","React.createElement","Router","navigationType","navigator","NavigationContext","LocationContext","RouteContext","outlet","matches","invariant","cond","message","matchRoutes","routes","locationArg","pathname","stripBasename","parsePath","branches","flattenRoutes","sort","score","siblings","slice","every","compareIndexes","routesMeta","meta","childrenIndex","rankRouteBranches","matchRouteBranch","parentsMeta","parentPath","forEach","route","index","relativePath","path","caseSensitive","startsWith","joinPaths","computeScore","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","segments","initialScore","some","filter","reduce","segment","test","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","params","pathnameBase","normalizePathname","pattern","paramNames","regexpSource","replace","paramName","endsWith","matcher","RegExp","undefined","compilePath","captureGroups","memo","splatValue","decodeURIComponent","safelyDecodeURIComponent","toLowerCase","nextChar","charAt","paths","join","useInRouterContext","useLocation","_renderMatches","parentMatches","reduceRight","Provider","element","Route","_props","_ref3","basenameProp","locationProp","NavigationType","static","staticProp","navigationContext","trailingPathname","Routes","_ref4","routeMatch","parentParams","parentPathnameBase","locationFromContext","parsedLocationArg","_parsedLocationArg$pa","useRoutes","createRoutesFromChildren","props","_arrayLikeToArray","arr","len","arr2","Array","_extends","bind","target","source","_slicedToArray","isArray","_i","_s","_e","_arr","_n","_d","err","unsupportedIterableToArray","_toConsumableArray","arrayLikeToArray","iter","from","_unsupportedIterableToArray","minLen","constructor","name"],"sourceRoot":""}