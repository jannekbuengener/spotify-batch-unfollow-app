{"version":3,"file":"static/js/537.2d9ea937.chunk.js","mappings":"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","sources":["util/use-call.ts","util/use-stream-call.ts","client/spotify/util/response-parser.ts","util/retry-fetch.ts","client/spotify/util/send-request.ts","client/spotify/api/get-user-artist-follows.ts","client/spotify/api/get-all-user-artist-follows.ts","client/spotify/api/get-current-user.ts","client/spotify/api/unfollow-artists.ts","util/array-chunk.ts","client/spotify/api/unfollow-artists-chunked.ts","client/spotify/index.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nimport { FetchError } from \"./retry-fetch\";\n\ninterface Function<A extends any[], R> {\n  (...args: A): Promise<R>;\n}\n\ntype UseCallResult<R> = [R | undefined, boolean, Error | undefined];\n\nconst useCall = <A extends any[], R>(\n  apiCall: Function<A, R>,\n  runNow: boolean,\n  ...apiArguments: A\n): UseCallResult<R> => {\n  const [result, setResult] = useState<R>();\n  const [error, setError] = useState<Error>();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!runNow) {\n      return;\n    }\n\n    setLoading(true);\n    setResult(undefined);\n    setError(undefined);\n\n    let abort: boolean = false;\n    (async () => {\n      try {\n        const callResult = await apiCall(...apiArguments);\n        if (abort === false) {\n          setResult(callResult);\n          setLoading(false);\n        }\n      } catch (error) {\n        const errorObj = error as FetchError;\n        if (errorObj.name !== \"AbortError\" && abort === false) {\n          setError(errorObj);\n          setLoading(false);\n        }\n      }\n    })();\n\n    return () => {\n      abort = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apiCall, runNow, ...apiArguments]);\n\n  return [result, loading, error];\n};\n\nexport default useCall;\n","import { useEffect, useState } from \"react\";\n\nimport { FetchError } from \"./retry-fetch\";\n\ninterface Generator<A extends any[], T, TReturn = any, TNext = unknown> {\n  (...args: A): AsyncGenerator<T, TReturn, TNext>;\n}\n\ntype UseCallResult<R> = [R[], boolean, Error | undefined];\n\nconst useStreamCall = <A extends any[], R>(\n  apiCall: Generator<A, R>,\n  runNow: boolean,\n  ...apiArguments: A\n): UseCallResult<R> => {\n  const [result, setResult] = useState<R[]>([]);\n  const [error, setError] = useState<Error>();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!runNow) {\n      return;\n    }\n\n    setLoading(true);\n    setResult([]);\n    setError(undefined);\n\n    let abort: boolean = false;\n    (async () => {\n      try {\n        for await (const newResult of apiCall(...apiArguments)) {\n          if (abort === false) {\n            setResult((oldResult) => [...oldResult, newResult]);\n          }\n        }\n        if (abort === false) {\n          setLoading(false);\n        }\n      } catch (error) {\n        const errorObj = error as FetchError;\n        if (errorObj.name !== \"AbortError\" && abort === false) {\n          setError(errorObj);\n          setLoading(false);\n        }\n      }\n    })();\n\n    return () => {\n      abort = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apiCall, runNow, ...apiArguments]);\n\n  return [result, loading, error];\n};\n\nexport default useStreamCall;\n","export const getJsonResponse = <T>(response: Response): Promise<T> => response.json();\n\nexport const getTextResponse = (response: Response): Promise<string> => response.text();\n","/**\n * Class for describing a fetch error details.\n */\nexport class FetchError extends Error {\n  private _status: number;\n  private _body: string;\n  private _headers: Headers;\n\n  constructor(status: number, body: string, headers: Headers) {\n    super(`Error has occurred performing the request due to error: ${body} [Status Code: ${status}]`);\n    this._status = status;\n    this._body = body;\n    this._headers = headers;\n  }\n\n  /**\n   * Get the status code of the error response.\n   */\n  public get status(): number {\n    return this._status;\n  }\n\n  /**\n   * Get the body of the error response.\n   */\n  public get body(): string {\n    return this._body;\n  }\n\n  /**\n   * Get the headers of the error response.\n   * @return {Headers}\n   */\n  public get headers(): Headers {\n    return this._headers;\n  }\n}\n\ninterface CountInfo {\n  attemptCount: number;\n  maxAttemptCount: number;\n}\n\n/**\n * Perform a fetch with a retry mechanism.\n * @param url The URL to fetch.\n * @param requestContext Context information for the request.\n * @param retryableErrorCodes Error codes to retry on.\n *\n * @returns The fetch result.\n * @throws {Error} The error response of the fetch.\n */\nconst retryFetch = async (\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n): Promise<Response> =>\n  new Promise(async (resolve, reject): Promise<void> => {\n    const countInfo: CountInfo = {\n      attemptCount: 0,\n      maxAttemptCount: 3,\n    };\n\n    handleFetchResponse(\n      resolve,\n      reject,\n      await fetch(url, requestContext),\n      countInfo,\n      url,\n      requestContext,\n      retryableErrorCodes,\n    );\n  });\n\nconst handleFetchResponse = async (\n  resolve: Function,\n  reject: Function,\n  response: Response,\n  countInfo: CountInfo,\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n) => {\n  if (response.ok) {\n    resolve(response);\n  } else if (\n    countInfo.attemptCount < countInfo.maxAttemptCount &&\n    isRetryableCode(response.status, retryableErrorCodes)\n  ) {\n    countInfo.attemptCount++;\n    performFetch(resolve, reject, response, countInfo, url, requestContext, retryableErrorCodes);\n  } else {\n    reject(new FetchError(response.status, await response.json(), response.headers));\n  }\n};\n\nconst getNextRetryTime = (response: Response, countInfo: CountInfo) => {\n  const nextRetryTime: string = response.headers.get(\"Retry-After\") || \"0\";\n  return Math.max(Math.pow(2, countInfo.attemptCount - 1) * 1000, Number(nextRetryTime));\n};\n\nconst performFetch = (\n  resolve: Function,\n  reject: Function,\n  priorResponse: Response,\n  countInfo: CountInfo,\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n) => {\n  setTimeout(async () => {\n    let response: Response = await fetch(url, requestContext);\n    handleFetchResponse(resolve, reject, response, countInfo, url, requestContext, retryableErrorCodes);\n  }, getNextRetryTime(priorResponse, countInfo));\n};\n\nconst isRetryableCode = (code: number, retryableErrorCodes?: number[]) =>\n  code >= 500 || (retryableErrorCodes && retryableErrorCodes.indexOf(code) >= 0);\n\nexport default retryFetch;\n","import retryFetch, { FetchError } from \"../../../util/retry-fetch\";\nimport config, { SPOTIFY_API_URL } from \"../api/config\";\n\ntype RequestPathParams = (string | number)[];\ntype RequestQueryParams = Record<string, string | number | null | undefined>;\n\nconst createQueryPath = (queryObj?: RequestQueryParams): string =>\n  queryObj\n    ? \"?\" +\n      Object.keys(queryObj)\n        .filter((queryKey: string) => queryObj[queryKey] !== undefined && queryObj[queryKey] !== null)\n        .map((queryKey: string) => `${queryKey}=${queryObj[queryKey]}`)\n        .join(\"&\")\n    : \"\";\n\nconst createRequestContext = (body?: BodyInit | null, headers?: HeadersInit, method?: string): RequestInit => ({\n  headers: {\n    Authorization: `Bearer ${config.userToken}`,\n    ...headers,\n  },\n  body,\n  method,\n});\n\nconst sendRequest = async (\n  pathParams: RequestPathParams,\n  queryParams?: RequestQueryParams,\n  body?: BodyInit | null,\n  headers?: HeadersInit,\n  method?: string,\n): Promise<Response> => {\n  const requestPath: string = [SPOTIFY_API_URL, ...pathParams].join(\"/\") + \"/\";\n\n  const queryPath: string = createQueryPath(queryParams);\n\n  return retryFetch(requestPath + queryPath, createRequestContext(body, headers, method), [429]).catch(\n    (error: FetchError): Response => {\n      if (error.status !== 401) {\n        throw error;\n      } else {\n        config.resetToken();\n        throw error;\n      }\n    },\n  );\n};\nexport default sendRequest;\n","import { Follows } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserArtistsFollows = async (limit: number, after?: string) =>\n  (\n    await getJsonResponse<Follows>(\n      await sendRequest([\"me\", \"following\"], {\n        type: \"artist\",\n        limit,\n        after,\n      }),\n    )\n  ).artists;\n\nexport default getUserArtistsFollows;\n","import { FollowedArtists } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getUserArtistFollows from \"./get-user-artist-follows\";\n\nconst getAllUserArtistFollows = async function* () {\n  let after = undefined;\n\n  do {\n    const results: FollowedArtists = await getUserArtistFollows(BATCH_SIZE, after);\n    yield results.items;\n\n    after = results.cursors.after;\n  } while (after !== undefined && after !== null);\n};\n\nexport default getAllUserArtistFollows;\n","import { UserInfo } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getCurrentUser = async () => getJsonResponse<UserInfo>(await sendRequest([\"me\"]));\n\nexport default getCurrentUser;\n","import { Artist } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowArtists = async (artists: Artist[]) =>\n  await sendRequest(\n    [\"me\", \"following\"],\n    {\n      type: \"artist\",\n    },\n    JSON.stringify({\n      ids: artists.map((artist: Artist): string => artist.id),\n    }),\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowArtists;\n","const arrayChunk = <T>(array: T[], size: number): T[][] => {\n  let chunks = [];\n\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, Math.min(array.length, i + size)));\n  }\n\n  return chunks;\n};\n\nexport default arrayChunk;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { FetchError } from \"../../../util/retry-fetch\";\nimport { Artist } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowArtists from \"./unfollow-artists\";\n\nconst unfollowArtistsChunked = async function* (artists: Artist[]) {\n  for (const chunkedArtists of arrayChunk(artists, BATCH_SIZE)) {\n    try {\n      await unfollowArtists(chunkedArtists);\n      yield {\n        failedArtists: [] as Artist[],\n        succeededArtists: chunkedArtists,\n      };\n    } catch (error) {\n      yield {\n        failedArtists: chunkedArtists,\n        succeededArtists: [] as Artist[],\n        error: error as FetchError,\n      };\n    }\n  }\n};\n\nexport default unfollowArtistsChunked;\n","import useCall from \"../../util/use-call\";\nimport useStreamCall from \"../../util/use-stream-call\";\nimport getAllUserArtistFollows from \"./api/get-all-user-artist-follows\";\nimport getCurrentUser from \"./api/get-current-user\";\nimport getUserArtistFollows from \"./api/get-user-artist-follows\";\nimport unfollowArtists from \"./api/unfollow-artists\";\nimport unfollowArtistsChunked from \"./api/unfollow-artists-chunked\";\nimport { Artist } from \"./model\";\n\nexport const useGetCurrentUser = (runNow: boolean = true) => {\n  return useCall(getCurrentUser, runNow);\n};\n\nexport const useGetUserArtistFollows = (limit: number = 50, runNow: boolean = true) => {\n  return useCall(getUserArtistFollows, runNow, limit);\n};\n\nexport const useGetAllUserArtistFollows = (runNow: boolean = true) => {\n  return useStreamCall(getAllUserArtistFollows, runNow);\n};\n\nexport const useUnfollowArtists = (artists: Artist[], runNow: boolean = true) => {\n  return useCall(unfollowArtists, runNow, artists);\n};\n\nexport const useUnfollowArtistsChunked = (artists: Artist[], runNow: boolean = true) => {\n  return useStreamCall(unfollowArtistsChunked, runNow, artists);\n};\n"],"names":["apiCall","runNow","apiArguments","useState","result","setResult","error","setError","loading","setLoading","useEffect","undefined","abort","callResult","errorObj","name","newResult","oldResult","getJsonResponse","response","json","FetchError","status","body","headers","_status","_body","_headers","this","Error","retryFetch","url","requestContext","retryableErrorCodes","Promise","resolve","reject","countInfo","attemptCount","maxAttemptCount","handleFetchResponse","fetch","ok","isRetryableCode","performFetch","priorResponse","setTimeout","nextRetryTime","get","Math","max","pow","Number","getNextRetryTime","code","indexOf","createQueryPath","queryObj","Object","keys","filter","queryKey","map","join","createRequestContext","method","Authorization","config","sendRequest","pathParams","queryParams","requestPath","SPOTIFY_API_URL","queryPath","catch","getUserArtistsFollows","limit","after","type","artists","getAllUserArtistFollows","getUserArtistFollows","BATCH_SIZE","results","items","cursors","getCurrentUser","unfollowArtists","JSON","stringify","ids","artist","id","array","size","chunks","i","length","push","slice","min","unfollowArtistsChunked","arrayChunk","chunkedArtists","failedArtists","succeededArtists","useGetCurrentUser","useCall","useGetAllUserArtistFollows","useStreamCall","useUnfollowArtistsChunked"],"sourceRoot":""}