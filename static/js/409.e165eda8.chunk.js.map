{"version":3,"file":"static/js/409.e165eda8.chunk.js","mappings":"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","sources":["util/use-call.ts","util/use-stream-call.ts","client/spotify/util/response-parser.ts","util/retry-fetch.ts","client/spotify/util/send-request.ts","client/spotify/api/get-user-artist-follows.ts","client/spotify/api/get-all-user-artist-follows.ts","client/spotify/api/get-user-show-follows.ts","client/spotify/api/get-all-user-show-follows.ts","client/spotify/api/get-current-user.ts","util/array-chunk.ts","client/spotify/api/unfollow-artists.ts","client/spotify/api/unfollow-artists-chunked.ts","client/spotify/api/unfollow-shows.ts","client/spotify/api/unfollow-shows-chunked.ts","client/spotify/api/unfollow-users.ts","client/spotify/api/unfollow-users-chunked.ts","client/spotify/index.ts","util/index.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\n\nimport { FetchError } from \"./retry-fetch\";\n\ninterface Function<A extends any[], R> {\n  (...args: A): Promise<R>;\n}\n\ntype UseCallResult<R> = [R | undefined, boolean, Error | undefined];\n\nconst useCall = <A extends any[], R>(\n  apiCall: Function<A, R>,\n  runNow: boolean,\n  ...apiArguments: A\n): UseCallResult<R> => {\n  const [result, setResult] = useState<R>();\n  const [error, setError] = useState<Error>();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!runNow) {\n      return;\n    }\n\n    setLoading(true);\n    setResult(undefined);\n    setError(undefined);\n\n    let abort: boolean = false;\n    (async () => {\n      try {\n        const callResult = await apiCall(...apiArguments);\n        if (!abort) {\n          setResult(callResult);\n        }\n\n        setLoading(false);\n      } catch (error) {\n        const errorObj = error as FetchError;\n        if (errorObj.name !== \"AbortError\" && !abort) {\n          setError(errorObj);\n        }\n\n        setLoading(false);\n      }\n    })();\n\n    return () => {\n      abort = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apiCall, runNow, ...apiArguments]);\n\n  return [result, loading, error];\n};\n\nexport default useCall;\n","import { useEffect, useState } from \"react\";\n\nimport { FetchError } from \"./retry-fetch\";\n\ninterface Generator<A extends any[], T, TReturn = any, TNext = unknown> {\n  (...args: A): AsyncGenerator<T, TReturn, TNext>;\n}\n\nexport type UseCallResult<R> = [R[], boolean, Error | undefined];\n\nconst useStreamCall = <A extends any[], R>(\n  apiCall: Generator<A, R>,\n  runNow: boolean,\n  ...apiArguments: A\n): UseCallResult<R> => {\n  const [result, setResult] = useState<R[]>([]);\n  const [error, setError] = useState<Error>();\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    if (!runNow) {\n      return;\n    }\n\n    setLoading(true);\n    setResult([]);\n    setError(undefined);\n\n    let abort: boolean = false;\n    (async () => {\n      try {\n        for await (const newResult of apiCall(...apiArguments)) {\n          setLoading(true);\n\n          if (abort) {\n            break;\n          }\n\n          setResult((oldResult) => [...oldResult, newResult]);\n        }\n\n        setLoading(false);\n      } catch (error) {\n        const errorObj = error as FetchError;\n        if (errorObj.name !== \"AbortError\" && !abort) {\n          setError(errorObj);\n        }\n\n        setLoading(false);\n      }\n    })();\n\n    return () => {\n      abort = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [apiCall, runNow, ...apiArguments]);\n\n  return [result, loading, error];\n};\n\nexport default useStreamCall;\n","export const getJsonResponse = <T>(response: Response): Promise<T> => response.json();\n\nexport const getTextResponse = (response: Response): Promise<string> => response.text();\n","/**\n * Class for describing a fetch error details.\n */\nexport class FetchError extends Error {\n  private _status: number;\n  private _body: string;\n  private _headers: Headers;\n\n  constructor(status: number, body: string, headers: Headers) {\n    super(`Error has occurred performing the request due to error: ${body} [Status Code: ${status}]`);\n    this._status = status;\n    this._body = body;\n    this._headers = headers;\n  }\n\n  /**\n   * Get the status code of the error response.\n   */\n  public get status(): number {\n    return this._status;\n  }\n\n  /**\n   * Get the body of the error response.\n   */\n  public get body(): string {\n    return this._body;\n  }\n\n  /**\n   * Get the headers of the error response.\n   * @return {Headers}\n   */\n  public get headers(): Headers {\n    return this._headers;\n  }\n}\n\ninterface CountInfo {\n  attemptCount: number;\n  maxAttemptCount: number;\n}\n\n/**\n * Perform a fetch with a retry mechanism.\n * @param url The URL to fetch.\n * @param requestContext Context information for the request.\n * @param retryableErrorCodes Error codes to retry on.\n *\n * @returns The fetch result.\n * @throws {Error} The error response of the fetch.\n */\nconst retryFetch = async (\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n): Promise<Response> =>\n  new Promise(async (resolve, reject): Promise<void> => {\n    const countInfo: CountInfo = {\n      attemptCount: 0,\n      maxAttemptCount: 3,\n    };\n\n    handleFetchResponse(\n      resolve,\n      reject,\n      await fetch(url, requestContext),\n      countInfo,\n      url,\n      requestContext,\n      retryableErrorCodes,\n    );\n  });\n\nconst handleFetchResponse = async (\n  resolve: Function,\n  reject: Function,\n  response: Response,\n  countInfo: CountInfo,\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n) => {\n  if (response.ok) {\n    resolve(response);\n  } else if (\n    countInfo.attemptCount < countInfo.maxAttemptCount &&\n    isRetryableCode(response.status, retryableErrorCodes)\n  ) {\n    countInfo.attemptCount++;\n    performFetch(resolve, reject, response, countInfo, url, requestContext, retryableErrorCodes);\n  } else {\n    reject(new FetchError(response.status, (await response.json()).error.message, response.headers));\n  }\n};\n\nconst getNextRetryTime = (response: Response, countInfo: CountInfo) => {\n  const nextRetryTime: string = response.headers.get(\"Retry-After\") || \"0\";\n  return Math.max(Math.pow(2, countInfo.attemptCount - 1) * 1000, Number(nextRetryTime));\n};\n\nconst performFetch = (\n  resolve: Function,\n  reject: Function,\n  priorResponse: Response,\n  countInfo: CountInfo,\n  url: string,\n  requestContext?: RequestInit,\n  retryableErrorCodes?: number[],\n) => {\n  setTimeout(async () => {\n    let response: Response = await fetch(url, requestContext);\n    handleFetchResponse(resolve, reject, response, countInfo, url, requestContext, retryableErrorCodes);\n  }, getNextRetryTime(priorResponse, countInfo));\n};\n\nconst isRetryableCode = (code: number, retryableErrorCodes?: number[]) =>\n  code >= 500 || (retryableErrorCodes && retryableErrorCodes.indexOf(code) >= 0);\n\nexport default retryFetch;\n","import { isNullOrUndefined } from \"../../../util\";\nimport retryFetch, { FetchError } from \"../../../util/retry-fetch\";\nimport config, { SPOTIFY_API_URL } from \"../api/config\";\n\ntype RequestPathParams = (string | number)[];\ntype RequestQueryParams = Record<string, string | number | null | undefined>;\n\nconst createQueryPath = (queryObj?: RequestQueryParams): string =>\n  queryObj\n    ? \"?\" +\n      Object.keys(queryObj)\n        .filter((queryKey: string) => !isNullOrUndefined(queryObj[queryKey]))\n        .map((queryKey: string) => `${queryKey}=${queryObj[queryKey]}`)\n        .join(\"&\")\n    : \"\";\n\nconst createRequestContext = (body?: BodyInit | null, headers?: HeadersInit, method?: string): RequestInit => ({\n  headers: {\n    Authorization: `Bearer ${config.userToken}`,\n    ...headers,\n  },\n  body,\n  method,\n});\n\nconst sendRequest = async (\n  pathParams: RequestPathParams,\n  queryParams?: RequestQueryParams,\n  body?: BodyInit | null,\n  headers?: HeadersInit,\n  method?: string,\n): Promise<Response> => {\n  const requestPath: string = [SPOTIFY_API_URL, ...pathParams].join(\"/\") + \"/\";\n\n  const queryPath: string = createQueryPath(queryParams);\n\n  return retryFetch(requestPath + queryPath, createRequestContext(body, headers, method), [429]).catch(\n    (error: FetchError): Response => {\n      if (error.status !== 401) {\n        throw error;\n      } else {\n        config.resetToken();\n        throw error;\n      }\n    },\n  );\n};\nexport default sendRequest;\n","import { UserFollowsResponse } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserArtistsFollows = async (type: \"artist\" | \"user\", limit: number, after?: string) => {\n  const results = await getJsonResponse<UserFollowsResponse>(\n    await sendRequest([\"me\", \"following\"], {\n      type,\n      limit,\n      after,\n    }),\n  );\n  return type === \"artist\" ? results.artists : results.users;\n};\n\nexport default getUserArtistsFollows;\n","import { isNullOrUndefined } from \"../../../util\";\nimport { Artist, FollowedArtistsList, FollowedUser, FollowedUsersList, UserInfo } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getUserArtistFollows from \"./get-user-artist-follows\";\n\nconst isUserInfo = (item: Artist | UserInfo): item is UserInfo => item.type === \"user\";\n\nconst getAllUserArtistFollows = async function* (type: \"artist\" | \"user\") {\n  let after = undefined;\n\n  do {\n    const results: FollowedArtistsList | FollowedUsersList = await getUserArtistFollows(type, BATCH_SIZE, after);\n\n    yield results.items.map((item) =>\n      !isUserInfo(item) ? item : ({ ...item, name: item.display_name } as FollowedUser),\n    );\n\n    after = results.cursors.after;\n  } while (!isNullOrUndefined(after));\n};\n\nexport default getAllUserArtistFollows;\n","import { ShowFollowsResponse } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getUserShowFollows = async (limit: number, offset?: number) =>\n  await getJsonResponse<ShowFollowsResponse>(\n    await sendRequest([\"me\", \"shows\"], {\n      limit,\n      offset,\n    }),\n  );\n\nexport default getUserShowFollows;\n","import { isNullOrUndefined } from \"../../../util\";\nimport { FollowedShowsList } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport getUserShowFollows from \"./get-user-show-follows\";\n\nconst getAllUserShowFollows = async function* () {\n  let offset = undefined;\n\n  do {\n    const results: FollowedShowsList = await getUserShowFollows(BATCH_SIZE, offset);\n    yield results.items.map(({ show }) => show);\n\n    offset = results.offset + results.limit;\n    if (offset >= results.total) {\n      offset = undefined;\n    }\n  } while (!isNullOrUndefined(offset));\n};\n\nexport default getAllUserShowFollows;\n","import { UserInfo } from \"../model\";\nimport { getJsonResponse } from \"../util/response-parser\";\nimport sendRequest from \"../util/send-request\";\n\nconst getCurrentUser = async () => getJsonResponse<UserInfo>(await sendRequest([\"me\"]));\n\nexport default getCurrentUser;\n","const arrayChunk = <T>(array: T[], size: number): T[][] => {\n  let chunks = [];\n\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, Math.min(array.length, i + size)));\n  }\n\n  return chunks;\n};\n\nexport default arrayChunk;\n","import { Artist } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowArtists = async (artists: Artist[]) =>\n  await sendRequest(\n    [\"me\", \"following\"],\n    {\n      type: \"artist\",\n    },\n    JSON.stringify({\n      ids: artists.map((artist: Artist): string => artist.id),\n    }),\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowArtists;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { Artist, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowArtists from \"./unfollow-artists\";\n\nconst unfollowArtistsChunked = async function* (artists: Artist[]) {\n  for (const chunkedArtists of arrayChunk(artists, BATCH_SIZE)) {\n    try {\n      await unfollowArtists(chunkedArtists);\n      yield {\n        succeeded: chunkedArtists,\n      } as UnfollowChunkedSuccessResult<Artist>;\n    } catch (error) {\n      yield {\n        failed: chunkedArtists,\n        error: error,\n      } as UnfollowChunkedFailureResult<Artist>;\n    }\n  }\n};\n\nexport default unfollowArtistsChunked;\n","import { Show } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowShows = async (shows: Show[]) =>\n  await sendRequest(\n    [\"me\", \"shows\"],\n    {},\n    JSON.stringify({\n      ids: shows.map((show: Show): string => show.id),\n    }),\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowShows;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { Show, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowShows from \"./unfollow-shows\";\n\nconst unfollowShowsChunked = async function* (shows: Show[]) {\n  for (const chunkedShows of arrayChunk(shows, BATCH_SIZE)) {\n    try {\n      await unfollowShows(chunkedShows);\n      yield {\n        succeeded: chunkedShows,\n      } as UnfollowChunkedSuccessResult<Show>;\n    } catch (error) {\n      yield {\n        failed: chunkedShows,\n        error: error,\n      } as UnfollowChunkedFailureResult<Show>;\n    }\n  }\n};\n\nexport default unfollowShowsChunked;\n","import { FollowedUser } from \"../model\";\nimport sendRequest from \"../util/send-request\";\n\nconst unfollowUsers = async (users: FollowedUser[]) =>\n  await sendRequest(\n    [\"me\", \"following\"],\n    {\n      type: \"user\",\n    },\n    JSON.stringify({\n      ids: users.map((user: FollowedUser): string => user.id),\n    }),\n    { \"Content-Type\": \"application/json\" },\n    \"DELETE\",\n  );\n\nexport default unfollowUsers;\n","import arrayChunk from \"../../../util/array-chunk\";\nimport { FollowedUser, UnfollowChunkedFailureResult, UnfollowChunkedSuccessResult } from \"../model\";\nimport { BATCH_SIZE } from \"./config\";\nimport unfollowUsers from \"./unfollow-users\";\n\nconst unfollowUsersChunked = async function* (users: FollowedUser[]) {\n  for (const chunkedUsers of arrayChunk(users, BATCH_SIZE)) {\n    try {\n      await unfollowUsers(chunkedUsers);\n      yield {\n        succeeded: chunkedUsers,\n      } as UnfollowChunkedSuccessResult<FollowedUser>;\n    } catch (error) {\n      yield {\n        failed: chunkedUsers,\n        error: error,\n      } as UnfollowChunkedFailureResult<FollowedUser>;\n    }\n  }\n};\n\nexport default unfollowUsersChunked;\n","import { Dispatch, SetStateAction, useEffect, useMemo, useState } from \"react\";\nimport useCall from \"../../util/use-call\";\nimport useStreamCall from \"../../util/use-stream-call\";\nimport getAllUserArtistFollows from \"./api/get-all-user-artist-follows\";\nimport getAllUserShowFollows from \"./api/get-all-user-show-follows\";\nimport getCurrentUser from \"./api/get-current-user\";\nimport unfollowArtistsChunked from \"./api/unfollow-artists-chunked\";\nimport unfollowShowsChunked from \"./api/unfollow-shows-chunked\";\nimport unfollowUsersChunked from \"./api/unfollow-users-chunked\";\nimport {\n  Artist,\n  Follow,\n  FollowType,\n  FollowedUser,\n  Show,\n  UnfollowChunkedResult,\n  getResultTypesForFollowTypes,\n} from \"./model\";\n\nexport const useGetCurrentUser = (runNow: boolean = true) => useCall(getCurrentUser, runNow);\n\nconst updateAllFollowsList = (\n  setAllFollows: Dispatch<SetStateAction<Follow[]>>,\n  newFollowsHandler: (...newFollows: Follow[]) => void,\n  followsChunked: Follow[][],\n) => {\n  if (followsChunked.length === 0) {\n    return;\n  }\n\n  const newFollows = followsChunked[followsChunked.length - 1];\n  setAllFollows((follows) => [...follows, ...newFollows]);\n\n  newFollowsHandler(...newFollows);\n};\n\nconst updateAllErrorsList = (setAllErrors: Dispatch<SetStateAction<Error[]>>, error?: Error) => {\n  if (!error) {\n    return;\n  }\n\n  setAllErrors((errors) => [...errors, error]);\n};\n\nexport const useGetAllUserArtistFollows = (\n  followTypes: FollowType[],\n  newFollowsHandler: (...newFollows: Follow[]) => void,\n  runNow = true,\n) => {\n  const [followedArtists, loadingArtists, artistsError] = useStreamCall(\n    getAllUserArtistFollows,\n    runNow && followTypes.includes(\"ARTIST\"),\n    \"artist\",\n  );\n  const [followedUsers, loadingUsers, usersError] = useStreamCall(\n    getAllUserArtistFollows,\n    runNow && followTypes.includes(\"USER\"),\n    \"user\",\n  );\n  const [followedShows, loadingShows, showsError] = useStreamCall(\n    getAllUserShowFollows,\n    runNow && followTypes.includes(\"SHOW\"),\n  );\n\n  const [allFollows, setAllFollows] = useState<Follow[]>([]);\n\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedArtists),\n    [followedArtists, newFollowsHandler, setAllFollows],\n  );\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedUsers),\n    [followedUsers, newFollowsHandler, setAllFollows],\n  );\n  useEffect(\n    () => updateAllFollowsList(setAllFollows, newFollowsHandler, followedShows),\n    [followedShows, newFollowsHandler, setAllFollows],\n  );\n\n  const [allErrors, setAllErrors] = useState<Error[]>([]);\n\n  useEffect(() => updateAllErrorsList(setAllErrors, artistsError), [artistsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, usersError), [usersError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, showsError), [showsError, setAllErrors]);\n\n  useEffect(() => {\n    const resultTypes = getResultTypesForFollowTypes(...followTypes);\n    setAllFollows((follows) => follows.filter(({ type }) => resultTypes.includes(type)));\n  }, [followTypes, setAllFollows, setAllErrors]);\n\n  return [allFollows, loadingArtists || loadingUsers || loadingShows, allErrors] as [Follow[], boolean, Error[]];\n};\n\nconst updateAllUnfollowsList = (\n  setAllUnfollows: Dispatch<SetStateAction<UnfollowChunkedResult<Follow>[]>>,\n  newUnfollowsHandler: (newUnfollows: UnfollowChunkedResult<Follow>) => void,\n  unfollowsChunked: UnfollowChunkedResult<Follow>[],\n) => {\n  if (unfollowsChunked.length === 0) {\n    return;\n  }\n\n  const newUnfollows = unfollowsChunked[unfollowsChunked.length - 1];\n  setAllUnfollows((unfollows) => [...unfollows, newUnfollows]);\n\n  newUnfollowsHandler(newUnfollows);\n};\n\nexport const useUnfollowFollowsChunked = (\n  follows: Follow[],\n  newUnfollowsHandler: (newUnfollows: UnfollowChunkedResult<Follow>) => void,\n  runNow: boolean = true,\n) => {\n  const followedArtists = useMemo(\n    () => follows.filter((follow): follow is Artist => follow.type === \"artist\"),\n    [follows],\n  );\n  const followedUsers = useMemo(\n    () => follows.filter((follow): follow is FollowedUser => follow.type === \"user\"),\n    [follows],\n  );\n  const followedShows = useMemo(() => follows.filter((follow): follow is Show => follow.type === \"show\"), [follows]);\n\n  const [unfollowArtists, loadingArtists, artistsError] = useStreamCall(\n    unfollowArtistsChunked,\n    runNow,\n    followedArtists,\n  );\n  const [unfollowUsers, loadingUsers, usersError] = useStreamCall(unfollowUsersChunked, runNow, followedUsers);\n  const [unfollowShows, loadingShows, showsError] = useStreamCall(unfollowShowsChunked, runNow, followedShows);\n\n  const [allUnfollows, setAllUnfollows] = useState<UnfollowChunkedResult<Follow>[]>([]);\n\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowArtists),\n    [unfollowArtists, newUnfollowsHandler, setAllUnfollows],\n  );\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowUsers),\n    [unfollowUsers, newUnfollowsHandler, setAllUnfollows],\n  );\n  useEffect(\n    () => updateAllUnfollowsList(setAllUnfollows, newUnfollowsHandler, unfollowShows),\n    [unfollowShows, newUnfollowsHandler, setAllUnfollows],\n  );\n\n  const [allErrors, setAllErrors] = useState<Error[]>([]);\n\n  useEffect(() => updateAllErrorsList(setAllErrors, artistsError), [artistsError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, usersError), [usersError, setAllErrors]);\n  useEffect(() => updateAllErrorsList(setAllErrors, showsError), [showsError, setAllErrors]);\n\n  return [allUnfollows, loadingArtists || loadingUsers || loadingShows, allErrors] as [\n    UnfollowChunkedResult<Follow>[],\n    boolean,\n    Error[],\n  ];\n};\n","export const isNullOrUndefined = (value: unknown): value is null | undefined => value === null || value === undefined;\n"],"names":["apiCall","runNow","apiArguments","useState","result","setResult","error","setError","loading","setLoading","useEffect","undefined","abort","callResult","errorObj","name","newResult","oldResult","getJsonResponse","response","json","FetchError","status","body","headers","_status","_body","_headers","this","Error","retryFetch","url","requestContext","retryableErrorCodes","Promise","resolve","reject","countInfo","attemptCount","maxAttemptCount","handleFetchResponse","fetch","ok","isRetryableCode","performFetch","message","priorResponse","setTimeout","nextRetryTime","get","Math","max","pow","Number","getNextRetryTime","code","indexOf","createQueryPath","queryObj","Object","keys","filter","queryKey","isNullOrUndefined","map","join","createRequestContext","method","Authorization","config","sendRequest","pathParams","queryParams","requestPath","SPOTIFY_API_URL","queryPath","catch","getUserArtistsFollows","type","limit","after","results","artists","users","isUserInfo","item","getAllUserArtistFollows","getUserArtistFollows","BATCH_SIZE","items","display_name","cursors","getUserShowFollows","offset","getAllUserShowFollows","show","total","getCurrentUser","array","size","chunks","i","length","push","slice","min","unfollowArtists","JSON","stringify","ids","artist","id","unfollowArtistsChunked","arrayChunk","chunkedArtists","succeeded","failed","unfollowShows","shows","unfollowShowsChunked","chunkedShows","unfollowUsers","user","unfollowUsersChunked","chunkedUsers","useGetCurrentUser","useCall","updateAllFollowsList","setAllFollows","newFollowsHandler","followsChunked","newFollows","follows","updateAllErrorsList","setAllErrors","errors","useGetAllUserArtistFollows","followTypes","useStreamCall","includes","followedArtists","loadingArtists","artistsError","followedUsers","loadingUsers","usersError","followedShows","loadingShows","showsError","allFollows","allErrors","resultTypes","getResultTypesForFollowTypes","updateAllUnfollowsList","setAllUnfollows","newUnfollowsHandler","unfollowsChunked","newUnfollows","unfollows","useUnfollowFollowsChunked","useMemo","follow","allUnfollows","value"],"sourceRoot":""}